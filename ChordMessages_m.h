//
// Generated file, do not edit! Created by nedtool 5.5 from ChordMessages.msg.
//

#ifndef __CHORDMESSAGES_M_H
#define __CHORDMESSAGES_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0505
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <NodeHandle.h>
#include <SuccessorList.h>
#include <FingerTable.h>
// }}

/**
 * Enum generated from <tt>ChordMessages.msg:44</tt> by nedtool.
 * <pre>
 * enum STATE
 * {
 *     PING = 0;
 *     JOIN = 1;
 *     FIND_SUCCESSOR = 2;
 *     FIND_PREDECESSOR = 3;
 *     NEWSUCCESSORHINT = 4;
 * 
 * }
 * </pre>
 */
enum STATE {
    PING = 0,
    JOIN = 1,
    FIND_SUCCESSOR = 2,
    FIND_PREDECESSOR = 3,
    NEWSUCCESSORHINT = 4
};

/**
 * Class generated from <tt>ChordMessages.msg:53</tt> by nedtool.
 * <pre>
 * packet BaseChordMessage
 * {
 * }
 * </pre>
 */
class BaseChordMessage : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const BaseChordMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseChordMessage&);

  public:
    BaseChordMessage(const char *name=nullptr, short kind=0);
    BaseChordMessage(const BaseChordMessage& other);
    virtual ~BaseChordMessage();
    BaseChordMessage& operator=(const BaseChordMessage& other);
    virtual BaseChordMessage *dup() const override {return new BaseChordMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BaseChordMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BaseChordMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:56</tt> by nedtool.
 * <pre>
 * packet BaseCallMessage extends BaseChordMessage
 * {
 * }
 * </pre>
 */
class BaseCallMessage : public ::BaseChordMessage
{
  protected:

  private:
    void copy(const BaseCallMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseCallMessage&);

  public:
    BaseCallMessage(const char *name=nullptr, short kind=0);
    BaseCallMessage(const BaseCallMessage& other);
    virtual ~BaseCallMessage();
    BaseCallMessage& operator=(const BaseCallMessage& other);
    virtual BaseCallMessage *dup() const override {return new BaseCallMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BaseCallMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BaseCallMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:59</tt> by nedtool.
 * <pre>
 * packet BaseResponseMessage extends BaseChordMessage
 * {
 * }
 * </pre>
 */
class BaseResponseMessage : public ::BaseChordMessage
{
  protected:

  private:
    void copy(const BaseResponseMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseResponseMessage&);

  public:
    BaseResponseMessage(const char *name=nullptr, short kind=0);
    BaseResponseMessage(const BaseResponseMessage& other);
    virtual ~BaseResponseMessage();
    BaseResponseMessage& operator=(const BaseResponseMessage& other);
    virtual BaseResponseMessage *dup() const override {return new BaseResponseMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BaseResponseMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BaseResponseMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:62</tt> by nedtool.
 * <pre>
 * packet BaseNetworkPacket
 * {
 * }
 * </pre>
 */
class BaseNetworkPacket : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const BaseNetworkPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BaseNetworkPacket&);

  public:
    BaseNetworkPacket(const char *name=nullptr, short kind=0);
    BaseNetworkPacket(const BaseNetworkPacket& other);
    virtual ~BaseNetworkPacket();
    BaseNetworkPacket& operator=(const BaseNetworkPacket& other);
    virtual BaseNetworkPacket *dup() const override {return new BaseNetworkPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BaseNetworkPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BaseNetworkPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:65</tt> by nedtool.
 * <pre>
 * packet Stabilization extends BaseNetworkPacket
 * {
 *     string ring[];
 *     string src;
 *     int hops;
 *     simtime_t start;
 * }
 * </pre>
 */
class Stabilization : public ::BaseNetworkPacket
{
  protected:
    ::omnetpp::opp_string *ring; // array ptr
    unsigned int ring_arraysize;
    ::omnetpp::opp_string src;
    int hops;
    ::omnetpp::simtime_t start;

  private:
    void copy(const Stabilization& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Stabilization&);

  public:
    Stabilization(const char *name=nullptr, short kind=0);
    Stabilization(const Stabilization& other);
    virtual ~Stabilization();
    Stabilization& operator=(const Stabilization& other);
    virtual Stabilization *dup() const override {return new Stabilization(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setRingArraySize(unsigned int size);
    virtual unsigned int getRingArraySize() const;
    virtual const char * getRing(unsigned int k) const;
    virtual void setRing(unsigned int k, const char * ring);
    virtual const char * getSrc() const;
    virtual void setSrc(const char * src);
    virtual int getHops() const;
    virtual void setHops(int hops);
    virtual ::omnetpp::simtime_t getStart() const;
    virtual void setStart(::omnetpp::simtime_t start);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Stabilization& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Stabilization& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:74</tt> by nedtool.
 * <pre>
 * // call/response for PING
 * // TODO: ci va messo qualcosa qua dentro?
 * packet PingTimeout extends BaseChordMessage
 * {
 *     string failed;
 * }
 * </pre>
 */
class PingTimeout : public ::BaseChordMessage
{
  protected:
    ::omnetpp::opp_string failed;

  private:
    void copy(const PingTimeout& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PingTimeout&);

  public:
    PingTimeout(const char *name=nullptr, short kind=0);
    PingTimeout(const PingTimeout& other);
    virtual ~PingTimeout();
    PingTimeout& operator=(const PingTimeout& other);
    virtual PingTimeout *dup() const override {return new PingTimeout(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getFailed() const;
    virtual void setFailed(const char * failed);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PingTimeout& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PingTimeout& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:78</tt> by nedtool.
 * <pre>
 * packet PingCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class PingCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const PingCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PingCall&);

  public:
    PingCall(const char *name=nullptr, short kind=0);
    PingCall(const PingCall& other);
    virtual ~PingCall();
    PingCall& operator=(const PingCall& other);
    virtual PingCall *dup() const override {return new PingCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PingCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PingCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:82</tt> by nedtool.
 * <pre>
 * packet PingResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class PingResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const PingResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PingResponse&);

  public:
    PingResponse(const char *name=nullptr, short kind=0);
    PingResponse(const PingResponse& other);
    virtual ~PingResponse();
    PingResponse& operator=(const PingResponse& other);
    virtual PingResponse *dup() const override {return new PingResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PingResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PingResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:86</tt> by nedtool.
 * <pre>
 * // call/response for JOIN
 * packet JoinCall extends BaseCallMessage
 * {
 *     string requester;
 *     string key;
 * }
 * </pre>
 */
class JoinCall : public ::BaseCallMessage
{
  protected:
    ::omnetpp::opp_string requester;
    ::omnetpp::opp_string key;

  private:
    void copy(const JoinCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const JoinCall&);

  public:
    JoinCall(const char *name=nullptr, short kind=0);
    JoinCall(const JoinCall& other);
    virtual ~JoinCall();
    JoinCall& operator=(const JoinCall& other);
    virtual JoinCall *dup() const override {return new JoinCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getRequester() const;
    virtual void setRequester(const char * requester);
    virtual const char * getKey() const;
    virtual void setKey(const char * key);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const JoinCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, JoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:91</tt> by nedtool.
 * <pre>
 * packet JoinResponse extends BaseResponseMessage
 * {
 *     int successorNum;// number of entries in the successor list
 *     string src;
 *     string successorNode[];    // successor list of the message originator
 *     string predecessorNode;    // in aggressiveJoinMode: predecessor hint
 * }
 * </pre>
 */
class JoinResponse : public ::BaseResponseMessage
{
  protected:
    int successorNum;
    ::omnetpp::opp_string src;
    ::omnetpp::opp_string *successorNode; // array ptr
    unsigned int successorNode_arraysize;
    ::omnetpp::opp_string predecessorNode;

  private:
    void copy(const JoinResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const JoinResponse&);

  public:
    JoinResponse(const char *name=nullptr, short kind=0);
    JoinResponse(const JoinResponse& other);
    virtual ~JoinResponse();
    JoinResponse& operator=(const JoinResponse& other);
    virtual JoinResponse *dup() const override {return new JoinResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getSuccessorNum() const;
    virtual void setSuccessorNum(int successorNum);
    virtual const char * getSrc() const;
    virtual void setSrc(const char * src);
    virtual void setSuccessorNodeArraySize(unsigned int size);
    virtual unsigned int getSuccessorNodeArraySize() const;
    virtual const char * getSuccessorNode(unsigned int k) const;
    virtual void setSuccessorNode(unsigned int k, const char * successorNode);
    virtual const char * getPredecessorNode() const;
    virtual void setPredecessorNode(const char * predecessorNode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const JoinResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, JoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:99</tt> by nedtool.
 * <pre>
 * // call/response for STABILIZE
 * packet StabilizeCall extends BaseCallMessage
 * {
 * }
 * </pre>
 */
class StabilizeCall : public ::BaseCallMessage
{
  protected:

  private:
    void copy(const StabilizeCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StabilizeCall&);

  public:
    StabilizeCall(const char *name=nullptr, short kind=0);
    StabilizeCall(const StabilizeCall& other);
    virtual ~StabilizeCall();
    StabilizeCall& operator=(const StabilizeCall& other);
    virtual StabilizeCall *dup() const override {return new StabilizeCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const StabilizeCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, StabilizeCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:102</tt> by nedtool.
 * <pre>
 * packet StabilizeResponse extends BaseResponseMessage
 * {
 *     string predecessorNode;
 *     string predecessorNodeIP;   // the predecessor of the message originator
 * }
 * </pre>
 */
class StabilizeResponse : public ::BaseResponseMessage
{
  protected:
    ::omnetpp::opp_string predecessorNode;
    ::omnetpp::opp_string predecessorNodeIP;

  private:
    void copy(const StabilizeResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StabilizeResponse&);

  public:
    StabilizeResponse(const char *name=nullptr, short kind=0);
    StabilizeResponse(const StabilizeResponse& other);
    virtual ~StabilizeResponse();
    StabilizeResponse& operator=(const StabilizeResponse& other);
    virtual StabilizeResponse *dup() const override {return new StabilizeResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getPredecessorNode() const;
    virtual void setPredecessorNode(const char * predecessorNode);
    virtual const char * getPredecessorNodeIP() const;
    virtual void setPredecessorNodeIP(const char * predecessorNodeIP);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const StabilizeResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, StabilizeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:108</tt> by nedtool.
 * <pre>
 * // call/response for NOTIFY
 * packet NotifyCall extends BaseCallMessage
 * {
 *     string failed;// TODO: qui non so cosa metterci, su oversim mette  TransportAddress failed = TransportAddress::UNSPECIFIED_NODE;
 * }
 * </pre>
 */
class NotifyCall : public ::BaseCallMessage
{
  protected:
    ::omnetpp::opp_string failed;

  private:
    void copy(const NotifyCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NotifyCall&);

  public:
    NotifyCall(const char *name=nullptr, short kind=0);
    NotifyCall(const NotifyCall& other);
    virtual ~NotifyCall();
    NotifyCall& operator=(const NotifyCall& other);
    virtual NotifyCall *dup() const override {return new NotifyCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getFailed() const;
    virtual void setFailed(const char * failed);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NotifyCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NotifyCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:112</tt> by nedtool.
 * <pre>
 * packet NotifyResponse extends BaseResponseMessage
 * {
 *     int successorNum; // number of entries in successor list
 *     string successorNode[]; // successor list of the node that sent the msg
 *  	//string predecessorNode;
 *  	//bool predecessorNodeSet; // this tells if the dest node has been set as new predecessor (for merging)  
 * }
 * </pre>
 */
class NotifyResponse : public ::BaseResponseMessage
{
  protected:
    int successorNum;
    ::omnetpp::opp_string *successorNode; // array ptr
    unsigned int successorNode_arraysize;

  private:
    void copy(const NotifyResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NotifyResponse&);

  public:
    NotifyResponse(const char *name=nullptr, short kind=0);
    NotifyResponse(const NotifyResponse& other);
    virtual ~NotifyResponse();
    NotifyResponse& operator=(const NotifyResponse& other);
    virtual NotifyResponse *dup() const override {return new NotifyResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getSuccessorNum() const;
    virtual void setSuccessorNum(int successorNum);
    virtual void setSuccessorNodeArraySize(unsigned int size);
    virtual unsigned int getSuccessorNodeArraySize() const;
    virtual const char * getSuccessorNode(unsigned int k) const;
    virtual void setSuccessorNode(unsigned int k, const char * successorNode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NotifyResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NotifyResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:120</tt> by nedtool.
 * <pre>
 * // call/response for FIXING the finger table
 * packet FixFingerCall extends BaseCallMessage
 * {
 *     int finger;
 *     string fingerKey;
 *     string requester; // the finger number that has to be fixed
 * }
 * </pre>
 */
class FixFingerCall : public ::BaseCallMessage
{
  protected:
    int finger;
    ::omnetpp::opp_string fingerKey;
    ::omnetpp::opp_string requester;

  private:
    void copy(const FixFingerCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FixFingerCall&);

  public:
    FixFingerCall(const char *name=nullptr, short kind=0);
    FixFingerCall(const FixFingerCall& other);
    virtual ~FixFingerCall();
    FixFingerCall& operator=(const FixFingerCall& other);
    virtual FixFingerCall *dup() const override {return new FixFingerCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getFinger() const;
    virtual void setFinger(int finger);
    virtual const char * getFingerKey() const;
    virtual void setFingerKey(const char * fingerKey);
    virtual const char * getRequester() const;
    virtual void setRequester(const char * requester);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FixFingerCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FixFingerCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:126</tt> by nedtool.
 * <pre>
 * packet FixFingerResponse extends BaseResponseMessage
 * {
 *     int finger; // the finger number that has to be fixed
 *     string successorNode; // the successor of the node that sent the msg
 * }
 * </pre>
 */
class FixFingerResponse : public ::BaseResponseMessage
{
  protected:
    int finger;
    ::omnetpp::opp_string successorNode;

  private:
    void copy(const FixFingerResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FixFingerResponse&);

  public:
    FixFingerResponse(const char *name=nullptr, short kind=0);
    FixFingerResponse(const FixFingerResponse& other);
    virtual ~FixFingerResponse();
    FixFingerResponse& operator=(const FixFingerResponse& other);
    virtual FixFingerResponse *dup() const override {return new FixFingerResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getFinger() const;
    virtual void setFinger(int finger);
    virtual const char * getSuccessorNode() const;
    virtual void setSuccessorNode(const char * successorNode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FixFingerResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FixFingerResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ChordMessages.msg:131</tt> by nedtool.
 * <pre>
 * packet NotifyBoostrapList extends BaseNetworkPacket
 * {
 *     string Overlaykey;
 * 
 * 
 * }
 * </pre>
 */
class NotifyBoostrapList : public ::BaseNetworkPacket
{
  protected:
    ::omnetpp::opp_string Overlaykey;

  private:
    void copy(const NotifyBoostrapList& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NotifyBoostrapList&);

  public:
    NotifyBoostrapList(const char *name=nullptr, short kind=0);
    NotifyBoostrapList(const NotifyBoostrapList& other);
    virtual ~NotifyBoostrapList();
    NotifyBoostrapList& operator=(const NotifyBoostrapList& other);
    virtual NotifyBoostrapList *dup() const override {return new NotifyBoostrapList(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getOverlaykey() const;
    virtual void setOverlaykey(const char * Overlaykey);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NotifyBoostrapList& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NotifyBoostrapList& obj) {obj.parsimUnpack(b);}


#endif // ifndef __CHORDMESSAGES_M_H

